当用户线程发起 I/O 操作后，网络数据读取操作会经历两个步骤：
  用户线程等待内核将数据从网卡拷贝到内核空间。
  内核将数据从内核空间拷贝到用户空间。
各种 I/O 模型的区别就是：它们实现这两个步骤的方式是不一样的。

同步阻塞 I/O：
  用户线程发起 read 调用后就阻塞了，让出 CPU。内核等待网卡数据到来，把数据从网卡拷贝到内核空间，
  接着把数据拷贝到用户空间，再把用户线程叫醒。

同步非阻塞 I/O：
  用户线程不断的发起 read 调用，数据没到内核空间时，每次都返回失败，直到数据到了内核空间，
  这一次 read 调用后，在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的，等数据到了用户空间再把线程叫醒。

I/O 多路复用：
  用户线程的读取操作分成两步了，线程先发起 select 调用，目的是问内核数据准备好了吗？
  等内核把数据准备好了，用户线程再发起 read 调用。在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的。
  那为什么叫 I/O 多路复用呢？因为一次 select 调用可以向内核查多个数据通道（Channel）的状态，所以叫多路复用。

异步 I/O：
  用户线程发起 read 调用的同时注册一个回调函数，read 立即返回，等内核将数据准备好后，
  再调用指定的回调函数完成处理。在这个过程中，用户线程一直没有阻塞。

NioEndpoint 组件( I/O 多路复用模型)
  我们知道，对于 Java 的多路复用器的使用，无非是两步：
  1. 创建一个 Seletor，在它身上注册各种感兴趣的事件，然后调用 select 方法，等待感兴趣的事情发生。
  2. 感兴趣的事情发生了，比如可以读了，这时便创建一个新的线程从 Channel 中读数据。

  它一共包含 LimitLatch、Acceptor、Poller、SocketProcessor 和 Executor 共 5 个组件