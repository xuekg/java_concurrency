数组用一块连续的内存空间，来存储相同类型的一组数据，
最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。

在平时的业务开发中，我们可以直接使用编程语言提供的容器类，
但是，如果是特别底层的开发，直接使用数组可能会更合适。


int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}

这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”，这是为什么呢？
因为，数组大小为 3，a[0]，a[1]，a[2]，而我们的代码因为书写错误，
导致 for 循环的结束条件错写为了 i<=3 而非 i<3，所以当 i=3 时，数组 a[3]访问越界。

解答：
对文中示例的无限循环有疑问的同学，建议去查函数调用的栈桢结构细节（操作系统或计算机体系结构的教材应该会讲到）。

函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。
变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。
当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。

i           高
arr         |
a[2]        |
a[1]        | 
a[0]        低

tip:栈分配地址是从高到低，arr数组内部的地址是从低到高，arr[3]的地址恰好是i的地址

关于数组越界访问导致死循环的问题，发现结果和编译器的实现有关，gcc有一个编译选项（-fno-stack-protector）用于关闭堆栈保护功能。
默认情况下启动了堆栈保护，不管i声明在前还是在后，i都会在数组之后压栈，只会循环4次；如果关闭堆栈保护功能，则会出现死循环。
请参考：https://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/index.html