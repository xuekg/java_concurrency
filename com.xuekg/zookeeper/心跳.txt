1.2 心跳检测
猿话一下，除了客户端每次的正常操作会刷新超时时间以外，客户端仍然需要一个机制去保持住这个会话，
这个机制就是我们平时听到过的心跳检测，原理是每次客户端启动的时候也会设置一个心跳检测的间隔时间，
在后台一直会去判断最后一次发送的时间戳和当前时间是否超过了该心跳检测的间隔，
如果超过了就会发送一个名为 PING 的请求，由于刚刚我们说了客户端的任意操作都会刷新该超时时间，PING 也不例外，
有了这个心跳机制就可以让客户端保持住和服务端的会话状态。而服务端收到 PING，除了刷新超时时间会简单的回复一个 PING 给客户端，
而客户端收到服务端的 PING 会直接丢弃不需要任何其他操作。

服务端之间是怎么进行心跳的:
服务端有一个重要的配置 tickTime（默认是 2000），还有另一个重要的配置 syncLimit（默认是 5）：
  首先 Leader 会以 1000 （tickTime / 2） 毫秒的频率去对各个 Follower 发起 PING 的请求
  每次检查 Follower 返回的 PING 的超时时间是否超过 10000 （tickTime * syncLimit），
    超过这个时间没有收到该 Follower 的 ACK 响应就关闭和该 Follower 的 socket 连接
  那 Follower 收到 PING 的消息后会回复一个 PING 给 Leader 并且会把自己记录的会话映射关系一起发过去
  还会立即清空自己本地的映射关系！

  会话是 ZK 中的重要概念，会话的状态会影响，服务端对客户端请求的处理
  客户端的每次操作都会延长会话的超时时间，并且客户端会主动发起 PING 请求来保持住会话，以免在空闲时会话超时被服务端关闭
  客户端的会话数据是保存在 Leader 端的，Follower 只是在每次操作的时候简单的记录下会话 ID 和超时时间的映射关系
  服务端之间的心跳 PING 是由 Leader 主动向 Follower 发起的
  Follower 收到 PING 后会将自己保存的会话映射数据发送给 Leader
  Leader 收到 Follower 的 PING 响应后会对发送过来的会话数据进行激活

  这个临时节点的特性就会被用在 ZK 实现分布式锁的时候，防止了客户端因意外退出没法执行释放锁的逻辑！