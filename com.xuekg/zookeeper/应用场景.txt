数据发布/订阅
  实现配置信息的集中式管理和数据的动态更新
  推拉结合：客户端向服务端注册自己需要关注的节点，一旦该节点的数据发生变更，服务端就会
  向客户端发送Watcher事件通知，客户端接收到消息通知后，需要主动到服务端获取最新的数据
    数据量通常比较小
    数据内容在运行时会发生动态变化
    集群中各机器共享，配置一致
负载均衡

命名服务
  全局唯一ID-UUID：能够非常简便地保证分布式环境中的唯一性
                  长度过长
                  含义不明
  zookeeper生成唯一ID：
    每一个数据节点都能够维护一份子节点的顺序顺列，当客户端对其创建一个顺序节点的时候
    zookeeper会自动以后缀的形式在其子节点上添加一个序号。
分布式协调/通知
  特有的Watcher注册和异步通知机制，实现对数据变更的实时处理
  不同的客户端都对zookeeper上同一个数据节点进行Watcher注册，监听数据节点的变化
  不仅能省去大量底层网络通信和协议设计上重复的工作，更为重要的一点是大大降低了系统
  之间的耦合，能够非常方便地实现异构系统之间的灵活通信。
集群管理
  zookeeper的两大特性
    Watcher监听及变更通知
    临时节点，客户端会话失效时，会被自动清除
  
Master选举
  zookeeper将会保证客户端无法重复创建一个已经存在的数据节点
  如果仅仅只是想实现Master选举的话，那么其实只需要有一个能够保证数据唯一性的组件即可，
    比如关系型数据库的主键模型就是非常不错的选择
  但是如果希望能够快速地进行集群Master动态选举，可以基于zookeeper来实现。
分布式锁
  排他锁
    保证当前有且仅有一个事务获得锁，并且在锁被释放后，所有正在等待获取锁的事务都能被通知到（临时节点）
  共享锁
    1.创建完节点后，获取/shared_lock节点下的所有子节点，并对该节点注册子节点变更的Watcher监听
    2.确定自己的节点序号在所有子节点中的顺序
    3.对于读请求
        如果没有比自己序号小的子节点，或者是所以比自己序号小的子节点都是读请求
        那么表明自己获取到了共享锁，开始读
        如果比自己序号小的子节点中有写请求，那么需要等待
      对于写请求
        如果自己不是序号最小的子节点，等待
    4.接收到watcher通知后，重复步骤1

  羊群效应：如果同一时间有多个节点对应的客户端完成事务或事务中断而引起节点消失，那么zookeeper服务器
    会在短时间内向其余的客户端发送大量的事件通知，但是事件通知能起效果的只有一个客户端，导致很多客户端
    无端接收到过多和自己不相关的事件通知。
  核心：每个节点对应的客户端只需要关注比自己序号小的那个相关节点的变更情况就可以了
    不需要关注全局的子列表变更情况。
  改进后的分布式锁实现
    1.客户端调用create()方法创建一个类似于/shared_lock/hostname-请求类型-序号 的临时顺序节点
    2.客户端调用getChildren()接口来获取所有已经创建的子节点列表，注意，这时候不注册任何的watcher
    3.如果无法获取共享锁，那么就调用exist()来对 比自己小的那个节点注册watcher
      读请求：向比自己序号小的最后一个写请求节点注册watcher监听
      写请求：向比自己序号小的最后一个节点注册watcher监听
    4.等待watcher通知，继续步骤2
分布式队列