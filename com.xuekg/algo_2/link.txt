如何用链表来实现 LRU 缓存淘汰策略呢？

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。
而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

todo：
1.如何基于链表实现 LRU 缓存淘汰算法？
  我的思路是这样的：
  我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。
  当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。
    1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
    2. 如果此数据没有在缓存链表中，又可以分为两种情况：
      如果此时缓存未满，则将此结点直接插入到链表的头部；
      如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。
2.如何利用数组实现 LRU 缓存淘汰策略呢？
3.如何判断一个字符串是否是回文字符串的问题
  1 快慢指针定位中间节点 
  2 从中间节点对后半部分逆序 
  3 前后半部分比较，判断是否为回文 
  4 后半部分逆序复原 
    时间复杂度On, 空间复杂度O1 